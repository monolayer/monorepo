// This file is auto-generated by @hey-api/openapi-ts

import * as GT from "./types.gen.js";

import * as MN from "../types.man.js";

import stream from "node:stream";

import { type DialOptions } from "docker-modem";

import { pino } from "pino";

import { ModemContext } from "./../../config.js";

export const logger = pino({
	level: process.env.DEBUG ?? "silent",
	transport:
		process.env.NODE_ENV !== "production"
			? {
					target: "pino-pretty",
					options: {
						colorize: true,
					},
				}
			: undefined,
});

function logCall(options: {
	path: unknown;
	method: unknown;
	options?: unknown;
}) {
	logger.debug({
		type: "dockerApi",
		path: options.path,
		method: options.method,
		...(options.options ? { options: options.options } : {}),
	});
}

export type CallbackFn<T = unknown> = (error: unknown, result: T) => void;

export type StreamCallbackFn = (
	error: unknown,
	stdout: Buffer | null,
	stderr: Buffer | null,
) => void;

export type Options = {
	abortSignal?: AbortSignal;
};

export type ExtendedOptions<T> = Options & T;

export type ExtendedOptionsWithBody<T, B> = ExtendedOptions<T> & B;

function getModem() {
	const docker = ModemContext.instance().docker;
	if (docker === undefined) {
		throw new Error("Missing Docker context. Did you call `setDockerContext`?");
	}
	return docker;
}

async function promisifiedDial<T>(options: DialOptions) {
	const promise = new Promise<T>((resolve, reject) => {
		const docker = getModem();
		docker.dial(options, (err, data) => {
			if (err) {
				return reject(err);
			}
			resolve(data as T);
		});
	});
	return await promise;
}

function demuxedDial(dialOptions: DialOptions, callback: StreamCallbackFn) {
	const docker = getModem();
	const stdoutStream = new stream.PassThrough();
	const stderrStream = new stream.PassThrough();
	stdoutStream.on("data", (chunk) => {
		callback(null, chunk, null);
	});
	stderrStream.on("data", (chunk) => {
		callback(null, null, chunk);
	});
	const demux = (error: unknown, stream: any) => {
		if (error !== null) {
			callback(error, null, null);
		} else {
			docker.demuxStream(stream, stdoutStream, stderrStream);
		}
	};
	docker.dial(dialOptions, demux);
}

function withoutBodyAndPath<
	T extends {
		body?: unknown;
		path?: unknown;
	},
>(opts: T) {
	return (({ body, path, ...rest }) => rest)(opts) as T;
}

function withoutPath<
	T extends {
		path?: unknown;
	},
>(opts: T) {
	return (({ path, ...rest }) => rest)(opts) as T;
}

/**
 * List containers
 *
 * Returns a list of containers. For details on the format, see the
 * [inspect endpoint](#operation/ContainerInspect).
 *
 * Note that it uses a different, smaller representation of a container
 * than inspecting a single container. For example, the list of linked
 * containers is not propagated .
 *
 *
 * @category Container
 */
export function containerList(
	opts: ExtendedOptions<GT.ContainerListData>,
): Promise<GT.ContainerListResponse> {
	const dialOptions = {
		path: `/containers/json?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a container
 *
 * @category Container
 */
export function containerCreate(
	opts: ExtendedOptions<GT.ContainerCreateData>,
): Promise<GT.ContainerCreateResponse> {
	const dialOptions = {
		path: `/containers/create?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			400: "bad parameter",
			404: "no such image",
			409: "conflict",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a container
 *
 * Return low-level information about a container.
 *
 * @category Container
 */
export function containerInspect(
	opts: ExtendedOptions<GT.ContainerInspectData>,
): Promise<GT.ContainerInspectResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/json?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List processes running inside a container
 *
 * On Unix systems, this is done by running the `ps` command. This endpoint
 * is not supported on Windows.
 *
 *
 * @category Container
 */
export function containerTop(
	opts: ExtendedOptions<GT.ContainerTopData>,
): Promise<GT.ContainerTopResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/top?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get container logs
 *
 * Get `stdout` and `stderr` logs from a container.
 *
 * Note: This endpoint works only for containers with the `json-file` or
 * `journald` logging driver.
 *
 *
 * @category Container
 */
export function containerLogs(
	opts: ExtendedOptions<GT.ContainerLogsData>,
	callback: StreamCallbackFn,
): void {
	const dialOptions = {
		path: `/containers/${opts.path.id}/logs?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		isStream: true,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	demuxedDial(dialOptions, callback);
}

/**
 * Get changes on a container’s filesystem
 *
 * Returns which files in a container's filesystem have been added, deleted,
 * or modified. The `Kind` of modification can be one of:
 *
 * - `0`: Modified ("C")
 * - `1`: Added ("A")
 * - `2`: Deleted ("D")
 *
 *
 * @category Container
 */
export function containerChanges(
	opts: ExtendedOptions<GT.ContainerChangesData>,
): Promise<GT.ContainerChangesResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/changes`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Export a container
 *
 * Export the contents of a container as a tarball.
 *
 * @category Container
 */
export function containerExport(
	opts: ExtendedOptions<GT.ContainerExportData>,
): Promise<GT.ContainerExportResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/export`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get container stats based on resource usage
 *
 * This endpoint returns a live stream of a container’s resource usage
 * statistics.
 *
 * The `precpu_stats` is the CPU statistic of the *previous* read, and is
 * used to calculate the CPU usage percentage. It is not an exact copy
 * of the `cpu_stats` field.
 *
 * If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
 * nil then for compatibility with older daemons the length of the
 * corresponding `cpu_usage.percpu_usage` array should be used.
 *
 * On a cgroup v2 host, the following fields are not set
 * * `blkio_stats`: all fields other than `io_service_bytes_recursive`
 * * `cpu_stats`: `cpu_usage.percpu_usage`
 * * `memory_stats`: `max_usage` and `failcnt`
 * Also, `memory_stats.stats` fields are incompatible with cgroup v1.
 *
 * To calculate the values shown by the `stats` command of the docker cli tool
 * the following formulas can be used:
 * * used_memory = `memory_stats.usage - memory_stats.stats.cache`
 * * available_memory = `memory_stats.limit`
 * * Memory usage % = `(used_memory / available_memory) * 100.0`
 * * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
 * * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
 * * number_cpus = `length(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
 * * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
 *
 *
 * @category Container
 */
export function containerStats(
	opts: ExtendedOptions<GT.ContainerStatsData>,
): Promise<GT.ContainerStatsResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/stats?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Resize a container TTY
 *
 * Resize the TTY for a container.
 *
 * @category Container
 */
export function containerResize(
	opts: ExtendedOptions<GT.ContainerResizeData>,
): Promise<GT.ContainerResizeResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/resize?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "cannot resize container",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Start a container
 *
 * @category Container
 */
export function containerStart(
	opts: ExtendedOptions<GT.ContainerStartData>,
): Promise<GT.ContainerStartResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/start?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			304: "container already started",
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Stop a container
 *
 * @category Container
 */
export function containerStop(
	opts: ExtendedOptions<GT.ContainerStopData>,
): Promise<GT.ContainerStopResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/stop?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			304: "container already stopped",
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Restart a container
 *
 * @category Container
 */
export function containerRestart(
	opts: ExtendedOptions<GT.ContainerRestartData>,
): Promise<GT.ContainerRestartResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/restart?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Kill a container
 *
 * Send a POSIX signal to a container, defaulting to killing to the
 * container.
 *
 *
 * @category Container
 */
export function containerKill(
	opts: ExtendedOptions<GT.ContainerKillData>,
): Promise<GT.ContainerKillResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/kill?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "no such container",
			409: "container is not running",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a container
 *
 * Change various configuration options of a container without having to
 * recreate it.
 *
 *
 * @category Container
 */
export function containerUpdate(
	opts: ExtendedOptions<GT.ContainerUpdateData>,
): Promise<GT.ContainerUpdateResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/update`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Rename a container
 *
 * @category Container
 */
export function containerRename(
	opts: ExtendedOptions<GT.ContainerRenameData>,
): Promise<GT.ContainerRenameResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/rename?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "no such container",
			409: "name already in use",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Pause a container
 *
 * Use the freezer cgroup to suspend all processes in a container.
 *
 * Traditionally, when suspending a process the `SIGSTOP` signal is used,
 * which is observable by the process being suspended. With the freezer
 * cgroup the process is unaware, and unable to capture, that it is being
 * suspended, and subsequently resumed.
 *
 *
 * @category Container
 */
export function containerPause(
	opts: ExtendedOptions<GT.ContainerPauseData>,
): Promise<GT.ContainerPauseResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/pause`,
		method: "POST",
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Unpause a container
 *
 * Resume a container which has been paused.
 *
 * @category Container
 */
export function containerUnpause(
	opts: ExtendedOptions<GT.ContainerUnpauseData>,
): Promise<GT.ContainerUnpauseResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/unpause`,
		method: "POST",
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Attach to a container
 *
 * Attach to a container to read its output or send it input. You can attach
 * to the same container multiple times and you can reattach to containers
 * that have been detached.
 *
 * Either the `stream` or `logs` parameter must be `true` for this endpoint
 * to do anything.
 *
 * See the [documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/)
 * for more details.
 *
 * ### Hijacking
 *
 * This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
 * and `stderr` on the same socket.
 *
 * This is the response from the daemon for an attach request:
 *
 * ```
 * HTTP/1.1 200 OK
 * Content-Type: application/vnd.docker.raw-stream
 *
 * [STREAM]
 * ```
 *
 * After the headers and two new lines, the TCP connection can now be used
 * for raw, bidirectional communication between the client and server.
 *
 * To hint potential proxies about connection hijacking, the Docker client
 * can also optionally send connection upgrade headers.
 *
 * For example, the client sends this request to upgrade the connection:
 *
 * ```
 * POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
 * Upgrade: tcp
 * Connection: Upgrade
 * ```
 *
 * The Docker daemon will respond with a `101 UPGRADED` response, and will
 * similarly follow with the raw stream:
 *
 * ```
 * HTTP/1.1 101 UPGRADED
 * Content-Type: application/vnd.docker.raw-stream
 * Connection: Upgrade
 * Upgrade: tcp
 *
 * [STREAM]
 * ```
 *
 * ### Stream format
 *
 * When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream
 * and the stream over the hijacked connected is multiplexed to separate out
 * `stdout` and `stderr`. The stream consists of a series of frames, each
 * containing a header and a payload.
 *
 * The header contains the information which the stream writes (`stdout` or
 * `stderr`). It also contains the size of the associated frame encoded in
 * the last four bytes (`uint32`).
 *
 * It is encoded on the first eight bytes like this:
 *
 * ```go
 * header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
 * ```
 *
 * `STREAM_TYPE` can be:
 *
 * - 0: `stdin` (is written on `stdout`)
 * - 1: `stdout`
 * - 2: `stderr`
 *
 * `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
 * encoded as big endian.
 *
 * Following the header is the payload, which is the specified number of
 * bytes of `STREAM_TYPE`.
 *
 * The simplest way to implement this protocol is the following:
 *
 * 1. Read 8 bytes.
 * 2. Choose `stdout` or `stderr` depending on the first byte.
 * 3. Extract the frame size from the last four bytes.
 * 4. Read the extracted size and output it on the correct output.
 * 5. Goto 1.
 *
 * ### Stream format when using a TTY
 *
 * When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the stream is not multiplexed. The data exchanged over the hijacked
 * connection is simply the raw data from the process PTY and client's
 * `stdin`.
 *
 *
 * @category Container
 */
export function containerAttach(
	opts: ExtendedOptions<GT.ContainerAttachData>,
	callback: StreamCallbackFn,
): void {
	const dialOptions = {
		path: `/containers/${opts.path.id}/attach?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		isStream: true,
		statusCodes: {
			101: true,
			200: true,
			400: "bad parameter",
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	demuxedDial(dialOptions, callback);
}

/**
 * Attach to a container via a websocket
 *
 * @category Container
 */
export function containerAttachWebsocket(
	opts: ExtendedOptions<GT.ContainerAttachWebsocketData>,
): Promise<GT.ContainerAttachWebsocketResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/attach/ws?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			101: true,
			200: true,
			400: "bad parameter",
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Wait for a container
 *
 * Block until a container stops, then returns the exit code.
 *
 * @category Container
 */
export function containerWait(
	opts: ExtendedOptions<GT.ContainerWaitData>,
): Promise<GT.ContainerWaitResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/wait?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Remove a container
 *
 * @category Container
 */
export function containerDelete(
	opts: ExtendedOptions<GT.ContainerDeleteData>,
): Promise<GT.ContainerDeleteResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}?`,
		method: "DELETE",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			400: "bad parameter",
			404: "no such container",
			409: "conflict",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get information about files in a container
 *
 * A response header `X-Docker-Container-Path-Stat` is returned, containing
 * a base64 - encoded JSON object with some filesystem header information
 * about the path.
 *
 *
 * @category Container
 */
export function containerArchiveInfo(
	opts: ExtendedOptions<GT.ContainerArchiveInfoData>,
): Promise<GT.ContainerArchiveInfoResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/archive?`,
		method: "HEAD",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "Bad parameter",
			404: "Container or path does not exist",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get an archive of a filesystem resource in a container
 *
 * Get a tar archive of a resource in the filesystem of container id.
 *
 * @category Container
 */
export function containerArchive(
	opts: ExtendedOptions<GT.ContainerArchiveData>,
): Promise<GT.ContainerArchiveResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/archive?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "Bad parameter",
			404: "Container or path does not exist",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Extract an archive of files or folders to a directory in a container
 *
 * Upload a tar archive to be extracted to a path in the filesystem of container id.
 * `path` parameter is asserted to be a directory. If it exists as a file, 400 error
 * will be returned with message "not a directory".
 *
 *
 * @category Container
 */
export function putContainerArchive(
	opts: ExtendedOptionsWithBody<
		GT.PutContainerArchiveData,
		MN.PutContainerArchiveBody
	>,
): Promise<GT.PutContainerArchiveResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/archive?`,
		method: "PUT",
		options: withoutBodyAndPath(opts).query,
		abortSignal: opts.abortSignal,
		file: opts.body,
		statusCodes: {
			200: true,
			400: "Bad parameter",
			403: "Permission denied, the volume or container rootfs is marked as read-only.",
			404: "No such container or path does not exist inside the container",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete stopped containers
 *
 * @category Container
 */
export function containerPrune(
	opts: ExtendedOptions<GT.ContainerPruneData>,
): Promise<GT.ContainerPruneResponse> {
	const dialOptions = {
		path: `/containers/prune?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List Images
 *
 * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
 *
 * @category Image
 */
export function imageList(
	opts: ExtendedOptions<GT.ImageListData>,
): Promise<GT.ImageListResponse> {
	const dialOptions = {
		path: `/images/json?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Build an image
 *
 * Build an image from a tar archive with a `Dockerfile` in it.
 *
 * The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
 *
 * The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
 *
 * The build is canceled if the client drops the connection by quitting or being killed.
 *
 *
 * @category Image
 */
export function imageBuild(
	opts: ExtendedOptionsWithBody<GT.ImageBuildData, MN.ImageBuildBody>,
): Promise<GT.ImageBuildResponse> {
	const dialOptions = {
		path: `/build?`,
		method: "POST",
		options: withoutBodyAndPath(opts).query,
		abortSignal: opts.abortSignal,
		file: opts.body,
		headers: opts.headers ?? {},
		statusCodes: {
			200: true,
			400: "Bad parameter",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete builder cache
 *
 * @category Image
 */
export function buildPrune(
	opts: ExtendedOptions<GT.BuildPruneData>,
): Promise<GT.BuildPruneResponse> {
	const dialOptions = {
		path: `/build/prune?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create an image
 *
 * Pull or import an image.
 *
 * @category Image
 */
export function imageCreate(
	opts: ExtendedOptions<GT.ImageCreateData>,
): Promise<GT.ImageCreateResponse> {
	const dialOptions = {
		path: `/images/create?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			200: true,
			404: "repository does not exist or no read access",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect an image
 *
 * Return low-level information about an image.
 *
 * @category Image
 */
export function imageInspect(
	opts: ExtendedOptions<GT.ImageInspectData>,
): Promise<GT.ImageInspectResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}/json`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "No such image",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get the history of an image
 *
 * Return parent layers of an image.
 *
 * @category Image
 */
export function imageHistory(
	opts: ExtendedOptions<GT.ImageHistoryData>,
): Promise<GT.ImageHistoryResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}/history`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "No such image",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Push an image
 *
 * Push an image to a registry.
 *
 * If you wish to push an image on to a private registry, that image must
 * already have a tag which references the registry. For example,
 * `registry.example.com/myimage:latest`.
 *
 * The push is cancelled if the HTTP connection is closed.
 *
 *
 * @category Image
 */
export function imagePush(
	opts: ExtendedOptions<GT.ImagePushData>,
): Promise<GT.ImagePushResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}/push?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			200: true,
			404: "No such image",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Tag an image
 *
 * Tag an image so that it becomes part of a repository.
 *
 * @category Image
 */
export function imageTag(
	opts: ExtendedOptions<GT.ImageTagData>,
): Promise<GT.ImageTagResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}/tag?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			400: "Bad parameter",
			404: "No such image",
			409: "Conflict",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Remove an image
 *
 * Remove an image, along with any untagged parent images that were
 * referenced by that image.
 *
 * Images can't be removed if they have descendant images, are being
 * used by a running container or are being used by a build.
 *
 *
 * @category Image
 */
export function imageDelete(
	opts: ExtendedOptions<GT.ImageDeleteData>,
): Promise<GT.ImageDeleteResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}?`,
		method: "DELETE",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "No such image",
			409: "Conflict",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Search images
 *
 * Search for an image on Docker Hub.
 *
 * @category Image
 */
export function imageSearch(
	opts: ExtendedOptions<GT.ImageSearchData>,
): Promise<GT.ImageSearchResponse> {
	const dialOptions = {
		path: `/images/search?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete unused images
 *
 * @category Image
 */
export function imagePrune(
	opts: ExtendedOptions<GT.ImagePruneData>,
): Promise<GT.ImagePruneResponse> {
	const dialOptions = {
		path: `/images/prune?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Check auth configuration
 *
 * Validate credentials for a registry and, if available, get an identity
 * token for accessing the registry without password.
 *
 *
 * @category System
 */
export function systemAuth(
	opts: ExtendedOptions<GT.SystemAuthData>,
): Promise<GT.SystemAuthResponse> {
	const dialOptions = {
		path: `/auth`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			204: true,
			401: "Auth error",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get system information
 *
 * @category System
 */
export function systemInfo(opts: Options): Promise<GT.SystemInfoResponse> {
	const dialOptions = {
		path: `/info`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get version
 *
 * Returns the version of Docker that is running and various information about the system that Docker is running on.
 *
 * @category System
 */
export function systemVersion(
	opts: Options,
): Promise<GT.SystemVersionResponse> {
	const dialOptions = {
		path: `/version`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a new image from a container
 *
 * @category Image
 */
export function imageCommit(
	opts: ExtendedOptions<GT.ImageCommitData>,
): Promise<GT.ImageCommitResponse> {
	const dialOptions = {
		path: `/commit?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			404: "no such container",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Monitor events
 *
 * Stream real-time events from the server.
 *
 * Various objects within Docker report events when something happens to them.
 *
 * Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, `update`, and `prune`
 *
 * Images report these events: `create`, `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune`
 *
 * Volumes report these events: `create`, `mount`, `unmount`, `destroy`, and `prune`
 *
 * Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune`
 *
 * The Docker daemon reports these events: `reload`
 *
 * Services report these events: `create`, `update`, and `remove`
 *
 * Nodes report these events: `create`, `update`, and `remove`
 *
 * Secrets report these events: `create`, `update`, and `remove`
 *
 * Configs report these events: `create`, `update`, and `remove`
 *
 * The Builder reports `prune` events
 *
 *
 * @category System
 */
export function systemEvents(
	opts: ExtendedOptions<GT.SystemEventsData>,
): Promise<GT.SystemEventsResponse> {
	const dialOptions = {
		path: `/events?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get data usage information
 *
 * @category System
 */
export function systemDataUsage(
	opts: ExtendedOptions<GT.SystemDataUsageData>,
): Promise<GT.SystemDataUsageResponse> {
	const dialOptions = {
		path: `/system/df?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Export an image
 *
 * Get a tarball containing all images and metadata for a repository.
 *
 * If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
 *
 * ### Image tarball format
 *
 * An image tarball contains one directory per image layer (named using its long ID), each containing these files:
 *
 * - `VERSION`: currently `1.0` - the file format version
 * - `json`: detailed layer information, similar to `docker inspect layer_id`
 * - `layer.tar`: A tarfile containing the filesystem changes in this layer
 *
 * The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.
 *
 * If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
 *
 * ```json
 * {
 *   "hello-world": {
 *     "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
 *   }
 * }
 * ```
 *
 *
 * @category Image
 */
export function imageGet(
	opts: ExtendedOptions<GT.ImageGetData>,
): Promise<GT.ImageGetResponse> {
	const dialOptions = {
		path: `/images/${opts.path.name}/get`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Export several images
 *
 * Get a tarball containing all images and metadata for several image
 * repositories.
 *
 * For each value of the `names` parameter: if it is a specific name and
 * tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
 * returned; if it is an image ID, similarly only that image (and its parents)
 * are returned and there would be no names referenced in the 'repositories'
 * file for this image ID.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 *
 * @category Image
 */
export function imageGetAll(
	opts: ExtendedOptions<GT.ImageGetAllData>,
): Promise<GT.ImageGetAllResponse> {
	const dialOptions = {
		path: `/images/get?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Import images
 *
 * Load a set of images and tags into a repository.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 *
 * @category Image
 */
export function imageLoad(
	opts: ExtendedOptions<GT.ImageLoadData>,
): Promise<GT.ImageLoadResponse> {
	const dialOptions = {
		path: `/images/load?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create an exec instance
 *
 * Run a command inside a running container.
 *
 * @category Exec
 */
export function containerExec(
	opts: ExtendedOptions<GT.ContainerExecData>,
): Promise<GT.ContainerExecResponse> {
	const dialOptions = {
		path: `/containers/${opts.path.id}/exec`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			404: "no such container",
			409: "container is paused",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Start an exec instance
 *
 * Starts a previously set up exec instance. If detach is true, this endpoint
 * returns immediately after starting the command. Otherwise, it sets up an
 * interactive session with the command.
 *
 *
 * @category Exec
 */
export function execStart(
	opts: ExtendedOptions<GT.ExecStartData>,
	callback: StreamCallbackFn,
): void {
	const dialOptions = {
		path: `/exec/${opts.path.id}/start`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		isStream: true,
		statusCodes: {
			200: true,
			404: "No such exec instance",
			409: "Container is stopped or paused",
		},
	};
	logCall(dialOptions);
	demuxedDial(dialOptions, callback);
}

/**
 * Resize an exec instance
 *
 * Resize the TTY session used by an exec instance. This endpoint only works
 * if `tty` was specified as part of creating and starting the exec instance.
 *
 *
 * @category Exec
 */
export function execResize(
	opts: ExtendedOptions<GT.ExecResizeData>,
): Promise<GT.ExecResizeResponse> {
	const dialOptions = {
		path: `/exec/${opts.path.id}/resize?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "No such exec instance",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect an exec instance
 *
 * Return low-level information about an exec instance.
 *
 * @category Exec
 */
export function execInspect(
	opts: ExtendedOptions<GT.ExecInspectData>,
): Promise<GT.ExecInspectResponse> {
	const dialOptions = {
		path: `/exec/${opts.path.id}/json`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "No such exec instance",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List volumes
 *
 * @category Volume
 */
export function volumeList(
	opts: ExtendedOptions<GT.VolumeListData>,
): Promise<GT.VolumeListResponse> {
	const dialOptions = {
		path: `/volumes?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a volume
 *
 * @category Volume
 */
export function volumeCreate(
	opts: ExtendedOptions<GT.VolumeCreateData>,
): Promise<GT.VolumeCreateResponse> {
	const dialOptions = {
		path: `/volumes/create`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a volume
 *
 * @category Volume
 */
export function volumeInspect(
	opts: ExtendedOptions<GT.VolumeInspectData>,
): Promise<GT.VolumeInspectResponse> {
	const dialOptions = {
		path: `/volumes/${opts.path.name}`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "No such volume",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * "Update a volume. Valid only for Swarm cluster volumes"
 *
 *
 * @category Volume
 */
export function volumeUpdate(
	opts: ExtendedOptions<GT.VolumeUpdateData>,
): Promise<GT.VolumeUpdateResponse> {
	const dialOptions = {
		path: `/volumes/${opts.path.name}?`,
		method: "PUT",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such volume",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Remove a volume
 *
 * Instruct the driver to remove the volume.
 *
 * @category Volume
 */
export function volumeDelete(
	opts: ExtendedOptions<GT.VolumeDeleteData>,
): Promise<GT.VolumeDeleteResponse> {
	const dialOptions = {
		path: `/volumes/${opts.path.name}?`,
		method: "DELETE",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "No such volume or volume driver",
			409: "Volume is in use and cannot be removed",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete unused volumes
 *
 * @category Volume
 */
export function volumePrune(
	opts: ExtendedOptions<GT.VolumePruneData>,
): Promise<GT.VolumePruneResponse> {
	const dialOptions = {
		path: `/volumes/prune?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List networks
 *
 * Returns a list of networks. For details on the format, see the
 * [network inspect endpoint](#operation/NetworkInspect).
 *
 * Note that it uses a different, smaller representation of a network than
 * inspecting a single network. For example, the list of containers attached
 * to the network is not propagated in API versions 1.28 and up.
 *
 *
 * @category Network
 */
export function networkList(
	opts: ExtendedOptions<GT.NetworkListData>,
): Promise<GT.NetworkListResponse> {
	const dialOptions = {
		path: `/networks?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a network
 *
 * @category Network
 */
export function networkInspect(
	opts: ExtendedOptions<GT.NetworkInspectData>,
): Promise<GT.NetworkInspectResponse> {
	const dialOptions = {
		path: `/networks/${opts.path.id}?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "Network not found",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Remove a network
 *
 * @category Network
 */
export function networkDelete(
	opts: ExtendedOptions<GT.NetworkDeleteData>,
): Promise<GT.NetworkDeleteResponse> {
	const dialOptions = {
		path: `/networks/${opts.path.id}`,
		method: "DELETE",
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			403: "operation not supported for pre-defined networks",
			404: "no such network",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a network
 *
 * @category Network
 */
export function networkCreate(
	opts: ExtendedOptions<GT.NetworkCreateData>,
): Promise<GT.NetworkCreateResponse> {
	const dialOptions = {
		path: `/networks/create`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			400: "bad parameter",
			403: "Forbidden operation. This happens when trying to create a network named after a pre-defined network,\nor when trying to create an overlay network on a daemon which is not part of a Swarm cluster.\n",
			404: "plugin not found",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Connect a container to a network
 *
 * The network must be either a local-scoped network or a swarm-scoped network with the `attachable` option set. A network cannot be re-attached to a running container
 *
 * @category Network
 */
export function networkConnect(
	opts: ExtendedOptions<GT.NetworkConnectData>,
): Promise<GT.NetworkConnectResponse> {
	const dialOptions = {
		path: `/networks/${opts.path.id}/connect`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			403: "Operation forbidden",
			404: "Network or container not found",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Disconnect a container from a network
 *
 * @category Network
 */
export function networkDisconnect(
	opts: ExtendedOptions<GT.NetworkDisconnectData>,
): Promise<GT.NetworkDisconnectResponse> {
	const dialOptions = {
		path: `/networks/${opts.path.id}/disconnect`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			403: "Operation not supported for swarm scoped networks",
			404: "Network or container not found",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete unused networks
 *
 * @category Network
 */
export function networkPrune(
	opts: ExtendedOptions<GT.NetworkPruneData>,
): Promise<GT.NetworkPruneResponse> {
	const dialOptions = {
		path: `/networks/prune?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List plugins
 *
 * Returns information about installed plugins.
 *
 * @category Plugin
 */
export function pluginList(
	opts: ExtendedOptions<GT.PluginListData>,
): Promise<GT.PluginListResponse> {
	const dialOptions = {
		path: `/plugins?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get plugin privileges
 *
 * @category Plugin
 */
export function getPluginPrivileges(
	opts: ExtendedOptions<GT.GetPluginPrivilegesData>,
): Promise<GT.GetPluginPrivilegesResponse> {
	const dialOptions = {
		path: `/plugins/privileges?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Install a plugin
 *
 * Pulls and installs a plugin. After the plugin is installed, it can be
 * enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
 *
 *
 * @category Plugin
 */
export function pluginPull(
	opts: ExtendedOptions<GT.PluginPullData>,
): Promise<GT.PluginPullResponse> {
	const dialOptions = {
		path: `/plugins/pull?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			204: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a plugin
 *
 * @category Plugin
 */
export function pluginInspect(
	opts: ExtendedOptions<GT.PluginInspectData>,
): Promise<GT.PluginInspectResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/json`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "plugin is not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Remove a plugin
 *
 * @category Plugin
 */
export function pluginDelete(
	opts: ExtendedOptions<GT.PluginDeleteData>,
): Promise<GT.PluginDeleteResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}?`,
		method: "DELETE",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "plugin is not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Enable a plugin
 *
 * @category Plugin
 */
export function pluginEnable(
	opts: ExtendedOptions<GT.PluginEnableData>,
): Promise<GT.PluginEnableResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/enable?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "plugin is not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Disable a plugin
 *
 * @category Plugin
 */
export function pluginDisable(
	opts: ExtendedOptions<GT.PluginDisableData>,
): Promise<GT.PluginDisableResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/disable?`,
		method: "POST",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "plugin is not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Upgrade a plugin
 *
 * @category Plugin
 */
export function pluginUpgrade(
	opts: ExtendedOptions<GT.PluginUpgradeData>,
): Promise<GT.PluginUpgradeResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/upgrade?`,
		method: "POST",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			204: true,
			404: "plugin not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a plugin
 *
 * @category Plugin
 */
export function pluginCreate(
	opts: ExtendedOptions<GT.PluginCreateData>,
): Promise<GT.PluginCreateResponse> {
	const dialOptions = {
		path: `/plugins/create?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Push a plugin
 *
 * Push a plugin to the registry.
 *
 *
 * @category Plugin
 */
export function pluginPush(
	opts: ExtendedOptions<GT.PluginPushData>,
): Promise<GT.PluginPushResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/push`,
		method: "POST",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "plugin not installed",
			500: "server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Configure a plugin
 *
 * @category Plugin
 */
export function pluginSet(
	opts: ExtendedOptions<GT.PluginSetData>,
): Promise<GT.PluginSetResponse> {
	const dialOptions = {
		path: `/plugins/${opts.path.name}/set`,
		method: "POST",
		options: withoutPath(opts).body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "Plugin not installed",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List nodes
 *
 * @category Node
 */
export function nodeList(
	opts: ExtendedOptions<GT.NodeListData>,
): Promise<GT.NodeListResponse> {
	const dialOptions = {
		path: `/nodes?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a node
 *
 * @category Node
 */
export function nodeInspect(
	opts: ExtendedOptions<GT.NodeInspectData>,
): Promise<GT.NodeInspectResponse> {
	const dialOptions = {
		path: `/nodes/${opts.path.id}`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such node",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete a node
 *
 * @category Node
 */
export function nodeDelete(
	opts: ExtendedOptions<GT.NodeDeleteData>,
): Promise<GT.NodeDeleteResponse> {
	const dialOptions = {
		path: `/nodes/${opts.path.id}?`,
		method: "DELETE",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such node",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a node
 *
 * @category Node
 */
export function nodeUpdate(
	opts: ExtendedOptions<GT.NodeUpdateData>,
): Promise<GT.NodeUpdateResponse> {
	const dialOptions = {
		path: `/nodes/${opts.path.id}/update?`,
		method: "POST",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such node",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect swarm
 *
 * @category Swarm
 */
export function swarmInspect(opts: Options): Promise<GT.SwarmInspectResponse> {
	const dialOptions = {
		path: `/swarm`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such swarm",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Initialize a new swarm
 *
 * @category Swarm
 */
export function swarmInit(
	opts: ExtendedOptions<GT.SwarmInitData>,
): Promise<GT.SwarmInitResponse> {
	const dialOptions = {
		path: `/swarm/init`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			500: "server error",
			503: "node is already part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Join an existing swarm
 *
 * @category Swarm
 */
export function swarmJoin(
	opts: ExtendedOptions<GT.SwarmJoinData>,
): Promise<GT.SwarmJoinResponse> {
	const dialOptions = {
		path: `/swarm/join`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			500: "server error",
			503: "node is already part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Leave a swarm
 *
 * @category Swarm
 */
export function swarmLeave(
	opts: ExtendedOptions<GT.SwarmLeaveData>,
): Promise<GT.SwarmLeaveResponse> {
	const dialOptions = {
		path: `/swarm/leave?`,
		method: "POST",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a swarm
 *
 * @category Swarm
 */
export function swarmUpdate(
	opts: ExtendedOptions<GT.SwarmUpdateData>,
): Promise<GT.SwarmUpdateResponse> {
	const dialOptions = {
		path: `/swarm/update?`,
		method: "POST",
		options: { ...opts.query, _body: opts.body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get the unlock key
 *
 * @category Swarm
 */
export function swarmUnlockkey(
	opts: Options,
): Promise<GT.SwarmUnlockkeyResponse> {
	const dialOptions = {
		path: `/swarm/unlockkey`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Unlock a locked manager
 *
 * @category Swarm
 */
export function swarmUnlock(
	opts: ExtendedOptions<GT.SwarmUnlockData>,
): Promise<GT.SwarmUnlockResponse> {
	const dialOptions = {
		path: `/swarm/unlock`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List services
 *
 * @category Service
 */
export function serviceList(
	opts: ExtendedOptions<GT.ServiceListData>,
): Promise<GT.ServiceListResponse> {
	const dialOptions = {
		path: `/services?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a service
 *
 * @category Service
 */
export function serviceCreate(
	opts: ExtendedOptions<GT.ServiceCreateData>,
): Promise<GT.ServiceCreateResponse> {
	const dialOptions = {
		path: `/services/create`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			201: true,
			400: "bad parameter",
			403: "network is not eligible for services",
			409: "name conflicts with an existing service",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a service
 *
 * @category Service
 */
export function serviceInspect(
	opts: ExtendedOptions<GT.ServiceInspectData>,
): Promise<GT.ServiceInspectResponse> {
	const dialOptions = {
		path: `/services/${opts.path.id}?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such service",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete a service
 *
 * @category Service
 */
export function serviceDelete(
	opts: ExtendedOptions<GT.ServiceDeleteData>,
): Promise<GT.ServiceDeleteResponse> {
	const dialOptions = {
		path: `/services/${opts.path.id}`,
		method: "DELETE",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such service",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a service
 *
 * @category Service
 */
export function serviceUpdate(
	opts: ExtendedOptions<GT.ServiceUpdateData>,
): Promise<GT.ServiceUpdateResponse> {
	const dialOptions = {
		path: `/services/${opts.path.id}/update?`,
		method: "POST",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		headers: opts.headers ?? {},
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such service",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get service logs
 *
 * Get `stdout` and `stderr` logs from a service. See also
 * [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 *
 * @category Service
 */
export function serviceLogs(
	opts: ExtendedOptions<GT.ServiceLogsData>,
	callback: StreamCallbackFn,
): void {
	const dialOptions = {
		path: `/services/${opts.path.id}/logs?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		isStream: true,
		statusCodes: {
			200: true,
			404: "no such service",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	demuxedDial(dialOptions, callback);
}

/**
 * List tasks
 *
 * @category Task
 */
export function taskList(
	opts: ExtendedOptions<GT.TaskListData>,
): Promise<GT.TaskListResponse> {
	const dialOptions = {
		path: `/tasks?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a task
 *
 * @category Task
 */
export function taskInspect(
	opts: ExtendedOptions<GT.TaskInspectData>,
): Promise<GT.TaskInspectResponse> {
	const dialOptions = {
		path: `/tasks/${opts.path.id}`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "no such task",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get task logs
 *
 * Get `stdout` and `stderr` logs from a task.
 * See also [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 *
 * @category Task
 */
export function taskLogs(
	opts: ExtendedOptions<GT.TaskLogsData>,
	callback: StreamCallbackFn,
): void {
	const dialOptions = {
		path: `/tasks/${opts.path.id}/logs?`,
		method: "GET",
		options: withoutPath(opts).query,
		abortSignal: opts.abortSignal,
		isStream: true,
		statusCodes: {
			200: true,
			404: "no such task",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	demuxedDial(dialOptions, callback);
}

/**
 * List secrets
 *
 * @category Secret
 */
export function secretList(
	opts: ExtendedOptions<GT.SecretListData>,
): Promise<GT.SecretListResponse> {
	const dialOptions = {
		path: `/secrets?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a secret
 *
 * @category Secret
 */
export function secretCreate(
	opts: ExtendedOptions<GT.SecretCreateData>,
): Promise<GT.SecretCreateResponse> {
	const dialOptions = {
		path: `/secrets/create`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			409: "name conflicts with an existing object",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a secret
 *
 * @category Secret
 */
export function secretInspect(
	opts: ExtendedOptions<GT.SecretInspectData>,
): Promise<GT.SecretInspectResponse> {
	const dialOptions = {
		path: `/secrets/${opts.path.id}`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "secret not found",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete a secret
 *
 * @category Secret
 */
export function secretDelete(
	opts: ExtendedOptions<GT.SecretDeleteData>,
): Promise<GT.SecretDeleteResponse> {
	const dialOptions = {
		path: `/secrets/${opts.path.id}`,
		method: "DELETE",
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "secret not found",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a Secret
 *
 * @category Secret
 */
export function secretUpdate(
	opts: ExtendedOptions<GT.SecretUpdateData>,
): Promise<GT.SecretUpdateResponse> {
	const dialOptions = {
		path: `/secrets/${opts.path.id}/update?`,
		method: "POST",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such secret",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * List configs
 *
 * @category Config
 */
export function configList(
	opts: ExtendedOptions<GT.ConfigListData>,
): Promise<GT.ConfigListResponse> {
	const dialOptions = {
		path: `/configs?`,
		method: "GET",
		options: opts.query,
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Create a config
 *
 * @category Config
 */
export function configCreate(
	opts: ExtendedOptions<GT.ConfigCreateData>,
): Promise<GT.ConfigCreateResponse> {
	const dialOptions = {
		path: `/configs/create`,
		method: "POST",
		options: opts.body,
		abortSignal: opts.abortSignal,
		statusCodes: {
			201: true,
			409: "name conflicts with an existing object",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Inspect a config
 *
 * @category Config
 */
export function configInspect(
	opts: ExtendedOptions<GT.ConfigInspectData>,
): Promise<GT.ConfigInspectResponse> {
	const dialOptions = {
		path: `/configs/${opts.path.id}`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			404: "config not found",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Delete a config
 *
 * @category Config
 */
export function configDelete(
	opts: ExtendedOptions<GT.ConfigDeleteData>,
): Promise<GT.ConfigDeleteResponse> {
	const dialOptions = {
		path: `/configs/${opts.path.id}`,
		method: "DELETE",
		abortSignal: opts.abortSignal,
		statusCodes: {
			204: true,
			404: "config not found",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Update a Config
 *
 * @category Config
 */
export function configUpdate(
	opts: ExtendedOptions<GT.ConfigUpdateData>,
): Promise<GT.ConfigUpdateResponse> {
	const dialOptions = {
		path: `/configs/${opts.path.id}/update?`,
		method: "POST",
		options: { ...withoutPath(opts).query, _body: withoutPath(opts).body },
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			400: "bad parameter",
			404: "no such config",
			500: "server error",
			503: "node is not part of a swarm",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}

/**
 * Get image information from the registry
 *
 * Return image digest and platform information by contacting the registry.
 *
 *
 * @category Distribution
 */
export function distributionInspect(
	opts: ExtendedOptions<GT.DistributionInspectData>,
): Promise<GT.DistributionInspectResponse> {
	const dialOptions = {
		path: `/distribution/${opts.path.name}/json`,
		method: "GET",
		abortSignal: opts.abortSignal,
		statusCodes: {
			200: true,
			401: "Failed authentication or no image found",
			500: "Server error",
		},
	};
	logCall(dialOptions);
	return promisifiedDial(dialOptions);
}
